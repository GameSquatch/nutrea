import{r as l}from"./index-DNcRkmDI.js";const W=({data:o,getId:v,getChildren:f,expandedState:n,onExpandedStateChange:d,onSelection:y,showRoot:D=!0,searchTerm:u,searchMatch:E,childSort:p})=>{const b=l.useRef({}),[P,R]=l.useState(o);P!==o&&(b.current={},R(o));const h=l.useCallback(s=>{let e;return v?e=v(s):e=s.id,e},[v]),m=l.useCallback(s=>{let e;return f?e=f(s):e=s.children,e},[f]),A=l.useCallback(s=>{const e=h(s);if((f||p)&&b.current[e])return b.current[e];const i=m(s);return p&&i?.sort(p),(f||p)&&(b.current[e]=i),i},[h,m,p,f]),L=l.useCallback(s=>{if(!d)throw new Error("If you want to call toggleExpanded on a node, define the onExpandedStateChange prop when calling useTree");n&&d({...n,[s]:!n[s]})},[n,d]),a=l.useMemo(()=>{const s=[];let e=[];const i=(r,t=0,N)=>{const w=h(r);let k;n?k=n[w]:k=!0;const C={...r,id:w,level:t,parentId:N,toggleExpanded:()=>L(w),isExpanded:k,select:()=>{if(!y)throw new Error("If you want to call select on a node, define the onSelection prop when calling useTree");y(r)},isSelected:c=>c===w,hasChildren:!1};e.push(C),u?E&&E(r,u)?(e.forEach(c=>s.push(c)),e=[]):!E&&r.name.includes(u)&&(e.forEach(c=>s.push(c)),e=[]):s.push(C);const g=A(r);C.hasChildren=g!==void 0&&g.length>0,g!==void 0&&(k||u)&&g.forEach(c=>i(c,t+1,w)),e.pop()};return D?i(o):A(o)?.forEach(t=>i(t,0,h(o))),s},[o,h,A,n,L,y,D,u,E]),K=l.useCallback((s,e)=>{s.preventDefault();const i=a[e];let r=e;switch(s.key){case"ArrowUp":e-1>=0&&(r=e-1);break;case"ArrowDown":e+1<a.length&&(r=e+1);break;case"ArrowLeft":{if(i.isExpanded){i.toggleExpanded();break}const t=i.parentId;if(t)for(r=e-1;a[r].id!==t;)r=r-1;break}case"ArrowRight":if(!i.isExpanded){i.toggleExpanded();break}i.hasChildren&&(r=e+1);break}return a[r].select(),r},[a]);return{visibleList:a,navigateWithKey:K}};export{W as u};
