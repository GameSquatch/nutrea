import{r as l}from"./index-DjPCFsOv.js";const U=({data:o,getId:g,getChildren:c,expandedState:f,onExpandedStateChange:v,onSelection:d,showRoot:C=!0,searchTerm:p,searchMatch:E,childSort:h})=>{const b=l.useRef({}),[L,P]=l.useState(o);L!==o&&(b.current={},P(o));const w=l.useCallback(s=>{let e;return g?e=g(s):e=s.id,e},[g]),D=l.useCallback(s=>{let e;return c?e=c(s):e=s.children,e},[c]),y=l.useCallback(s=>{const e=w(s);if((c||h)&&b.current[e])return b.current[e];const i=D(s);return h&&i?.sort(h),(c||h)&&(b.current[e]=i),i},[w,D,h,c]),m=l.useCallback(s=>{if(!v)throw new Error("If you want to call toggleExpanded on a node, define the onExpandedStateChange prop when calling useTree");v({...f,[s]:!f[s]})},[f,v]),a=l.useMemo(()=>{const s=[];let e=[];const i=(r,n=0,K)=>{const u=w(r),A={...r,id:u,level:n,parentId:K,toggleExpanded:()=>m(u),isExpanded:f[u],select:()=>{if(!d)throw new Error("If you want to call select on a node, define the onSelection prop when calling useTree");d(r)},isSelected:t=>t===u,hasChildren:!1};e.push(A),p?E&&E(r,p)?(e.forEach(t=>s.push(t)),e=[]):!E&&r.name.includes(p)&&(e.forEach(t=>s.push(t)),e=[]):s.push(A);const k=y(r);A.hasChildren=k!==void 0&&k.length>0,k!==void 0&&(f[u]||p)&&k.forEach(t=>i(t,n+1,u)),e.pop()};return C?i(o):y(o)?.forEach(n=>i(n,0,w(o))),s},[o,w,y,f,m,d,C,p,E]),R=l.useCallback((s,e)=>{s.preventDefault();const i=a[e];let r=e;switch(s.key){case"ArrowUp":e-1>=0&&(r=e-1);break;case"ArrowDown":e+1<a.length&&(r=e+1);break;case"ArrowLeft":{if(i.isExpanded){i.toggleExpanded();break}const n=i.parentId;if(n)for(r=e-1;a[r].id!==n;)r=r-1;break}case"ArrowRight":if(!i.isExpanded){i.toggleExpanded();break}i.hasChildren&&(r=e+1);break}return a[r].select(),r},[a]);return{visibleList:a,navigateWithKey:R}};export{U as u};
